

# Monitoring

## Metrics vs Monitoring

Metrics are measurements or data points that tell you what is happening. For example, the number of steps you walk each day, your heart rate, or the temperature outsideâ€”these are all metrics.

Monitoring is the process of keeping an eye on these metrics over time to understand whatâ€™s normal, identify changes, and detect problems. It's like watching your step count daily to see if you're meeting your fitness goal or checking your heart rate to make sure it's in a healthy range.

## ğŸš€ Prometheus
- Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud.
- It is known for its robust data model, powerful query language (PromQL), and the ability to generate alerts based on the collected time-series data.
- It can be configured and set up on both bare-metal servers and container environments like Kubernetes.

## ğŸ  Prometheus Architecture
- The architecture of Prometheus is designed to be highly flexible, scalable, and modular.
- It consists of several core components, each responsible for a specific aspect of the monitoring process.

![Prometheus Architecture](images/prometheus-architecture.gif)

### ğŸ”¥ Prometheus Server
- Prometheus server is the core of the monitoring system. It is responsible for scraping metrics from various configured targets, storing them in its time-series database (TSDB), and serving queries through its HTTP API.
- Components:
    - **Retrieval**: This module handles the scraping of metrics from endpoints, which are discovered either through static configurations or dynamic service discovery methods.
    - **TSDB (Time Series Database)**: The data scraped from targets is stored in the TSDB, which is designed to handle high volumes of time-series data efficiently.
    - **HTTP Server**: This provides an API for querying data using PromQL, retrieving metadata, and interacting with other components of the Prometheus ecosystem.
- **Storage**: The scraped data is stored on local disk (HDD/SSD) in a format optimized for time-series data.

### ğŸŒ Service Discovery
- Service discovery automatically identifies and manages the list of scrape targets (i.e., services or applications) that Prometheus monitors.
- This is crucial in dynamic environments like Kubernetes where services are constantly being created and destroyed.
- Components:
    - **Kubernetes**: In Kubernetes environments, Prometheus can automatically discover services, pods, and nodes using Kubernetes API, ensuring it monitors the most up-to-date list of targets.
    - **File SD (Service Discovery)**: Prometheus can also read static target configurations from files, allowing for flexibility in environments where dynamic service discovery is not used.

### ğŸ“¤ Pushgateway
- The Pushgateway is used to expose metrics from short-lived jobs or applications that cannot be scraped directly by Prometheus.
- These jobs push their metrics to the Pushgateway, which then makes them available for Prometheus to scrape(pull).
- Use Case:
    - It's particularly useful for batch jobs or tasks that have a limited lifespan and would otherwise not have their metrics collected.

### ğŸš¨ Alertmanager
- The Alertmanager is responsible for managing alerts generated by the Prometheus server.
- It takes care of deduplicating, grouping, and routing alerts to the appropriate notification channels such as PagerDuty, email, or Slack.

### ğŸ§² Exporters
- Exporters are small applications that collect metrics from various third-party systems and expose them in a format Prometheus can scrape. They are essential for monitoring systems that do not natively support Prometheus.
- Types of Exporters:
    - Common exporters include the Node Exporter (for hardware metrics), the MySQL Exporter (for database metrics), and various other application-specific exporters.

### ğŸ–¥ï¸ Prometheus Web UI
- The Prometheus Web UI allows users to explore the collected metrics data, run ad-hoc PromQL queries, and visualize the results directly within Prometheus.

### ğŸ“Š Grafana
- Grafana is a powerful dashboard and visualization tool that integrates with Prometheus to provide rich, customizable visualizations of the metrics data.

### ğŸ”Œ API Clients
- API clients interact with Prometheus through its HTTP API to fetch data, query metrics, and integrate Prometheus with other systems or custom applications.



```
ğŸ¥ Real-World Example: Patient Monitoring
Scenario

ğŸ‘©â€âš•ï¸ Nurse collects data:

Blood Pressure (BP)

Heart Rate

Temperature

ğŸ©º Doctor checks the data trends and decides:

Is patient stable?

Is condition worsening?

Immediate action needed?

Here:

Real World	DevOps Equivalent
Patient	Application / Server
Nurse	Monitoring Agent
BP / Heartbeat	CPU / Memory / Latency
Doctor	DevOps Engineer
Medical Chart	Dashboard (Grafana)
ğŸ” What is a Metric?

A metric is:

A numeric value measured over time.

Examples in DevOps:

CPU usage = 75%

Memory usage = 3GB

Response time = 250ms

Error rate = 2%

Metrics always have:

ğŸ“Œ Name (CPU usage)

ğŸ“Œ Value (75%)

ğŸ“Œ Timestamp (10:01 AM)

ğŸ“Œ Labels (server=prod-1)

â³ Why Historical Data is Important?

Like your example:

At 10:00 AM â†’ Heartbeat normal

At 10:05 AM â†’ Slight increase

At 10:10 AM â†’ High spike

Doctor sees trend.

Similarly in DevOps:

CPU normal at 40%

Suddenly spike to 95%

Then memory also increases

Then application crashes

ğŸ‘‰ Metrics help us detect problems before failure happens.

ğŸ— DevOps Observability Architecture

Letâ€™s understand full flow.

Step 1: Data Collection (Nurse)

Monitoring agent collects metrics.

Examples:

Prometheus

Node Exporter

Datadog

They collect:

CPU

Memory

Disk

Network

Application metrics

Step 2: Store Metrics (Medical Records)

Metrics are stored in a Time Series Database (TSDB).

Time series means:

10:00 â†’ CPU 40%
10:01 â†’ CPU 42%
10:02 â†’ CPU 80%

Prometheus stores metrics like this.

Step 3: Visualization (Medical Chart)

Tools like:

Grafana

Show graphs and dashboards.

ğŸ“Š Diagram 1 â€“ Observability Flow
Application / Server (Patient)
        â†“
Monitoring Agent (Nurse)
        â†“
Time Series DB (Medical Record)
        â†“
Dashboard (Doctor View)
        â†“
Alert System (Emergency Call)
ğŸ“ˆ Example Graph (CPU Spike)

Imagine this:

CPU %
100 |              *
 90 |            *
 80 |         *
 70 |      *
 60 |
 50 |   *
 40 | *
    -------------------------
      10:00 10:05 10:10

Doctor conclusion:

Sudden spike

Possible overload

Check logs

Scale server

ğŸ”” What Happens When Threshold Crosses?

Example:

If CPU > 85% for 5 minutes

Trigger alert

Tools:

Prometheus Alertmanager

Datadog Alerts

Just like:

If heart rate > 120 â†’ ICU alert ğŸš¨

ğŸ“Š Types of Metrics in DevOps
1ï¸âƒ£ Infrastructure Metrics

CPU usage

Memory usage

Disk I/O

Network traffic

2ï¸âƒ£ Application Metrics

Request count

Error rate

Latency

Throughput

3ï¸âƒ£ Business Metrics

Orders per minute

Active users

Revenue/hour

ğŸ§  Observability = 3 Pillars

Metrics are one pillar.

Pillar	Meaning
Metrics	Numbers over time
Logs	Detailed event records
Traces	Request journey tracking

Tools:

Metrics â†’ Prometheus

Logs â†’ ELK Stack

Traces â†’ Jaeger

ğŸ— Real Production Scenario (Backend App)

Suppose:

You deployed Java microservice.

Suddenly users say: "App is slow."

You check dashboard:

Metric	Value
CPU	92%
Memory	80%
Latency	3 seconds
Error Rate	5%

From metrics:

CPU spike

Response time high

Errors increasing

Conclusion:

Traffic spike OR memory leak OR thread blocking.

Without metrics â†’ You are blind.
With metrics â†’ You see health in real-time.

ğŸ§© Why Metrics Are Powerful?

Because they:

Show trends

Help capacity planning

Help scaling decisions

Trigger alerts automatically

Reduce downtime

ğŸš€ Simple Definition for Interviews

If interviewer asks:

What are metrics in observability?

You can say:

"Metrics are numerical measurements collected over time that help monitor the health and performance of infrastructure and applications. They are stored in time-series databases and visualized in dashboards to detect trends, anomalies, and trigger alerts."

ğŸ Final Understanding

Your example is 100% correct.

âœ” Nurse = Monitoring agent
âœ” BP / Heartbeat = Metrics
âœ” Historical data = Time series
âœ” Doctor = DevOps Engineer
âœ” Medical chart = Dashboard
âœ” Emergency call = Alert

If you want, I can next explain:

How Prometheus actually scrapes metrics internally

Difference between Pull vs Push model

How metrics are exposed in Java Spring Boot

Just tell me which direction you want to go, Ganesh ğŸ‘¨â€ğŸ’»

```








# ğŸ› ï¸  Installation & Configurations
## ğŸ“¦ Step 1: Create EKS Cluster

### Prerequisites
- Download and Install AWS Cli - Please Refer [this]("https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html") link.
- Setup and configure AWS CLI using the `aws configure` command.
- Install and configure eksctl using the steps mentioned [here]("https://eksctl.io/installation/").
- Install and configure kubectl as mentioned [here]("https://kubernetes.io/docs/tasks/tools/").


```bash
eksctl create cluster --name=observability \
                      --region=us-east-1 \
                      --zones=us-east-1a,us-east-1b \
                      --without-nodegroup
```
```bash
eksctl utils associate-iam-oidc-provider \
    --region us-east-1 \
    --cluster observability \
    --approve
```
```bash
eksctl create nodegroup --cluster=observability \
                        --region=us-east-1 \
                        --name=observability-ng-private \
                        --node-type=t3.medium \
                        --nodes-min=2 \
                        --nodes-max=3 \
                        --node-volume-size=20 \
                        --managed \
                        --asg-access \
                        --external-dns-access \
                        --full-ecr-access \
                        --appmesh-access \
                        --alb-ingress-access \
                        --node-private-networking

# Update ./kube/config file
aws eks update-kubeconfig --name observability
```

### ğŸ§° Step 2: Install kube-prometheus-stack
```bash
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
```

```
ğŸ§° Step 2: Install kube-prometheus-stack

First understand:

What is kube-prometheus-stack?

kube-prometheus-stack
It is a Helm chart that installs:

Prometheus â†’ Collect metrics

Grafana â†’ Dashboards

Alertmanager â†’ Alerts

Node Exporter â†’ Node metrics

kube-state-metrics â†’ Kubernetes object metrics

Instead of installing everything manually, this chart installs all at once.
Now Helm knows where to download monitoring charts from.

```

### ğŸš€ Step 3: Deploy the chart into a new namespace "monitoring"
```bash
kubectl create ns monitoring
```
```bash
cd day-2

helm install monitoring prometheus-community/kube-prometheus-stack \
-n monitoring \
-f ./custom_kube_prometheus_stack.yml
```

### âœ… Step 4: Verify the Installation
```bash
kubectl get all -n monitoring
```
- **Prometheus UI**:
```bash
kubectl port-forward service/prometheus-operated -n monitoring 9090:9090
```

**NOTE:** If you are using an EC2 Instance or Cloud VM, you need to pass `--address 0.0.0.0` to the above command. Then you can access the UI on <instance-ip:port>

- **Grafana UI**: password is `prom-operator`
```bash
kubectl port-forward service/monitoring-grafana -n monitoring 8080:80
```
- **Alertmanager UI**:
```bash
kubectl port-forward service/alertmanager-operated -n monitoring 9093:9093
```

### ğŸ§¼ Step 5: Clean UP
- **Uninstall helm chart**:
```bash
helm uninstall monitoring --namespace monitoring
```
- **Delete namespace**:
```bash
kubectl delete ns monitoring
```
- **Delete Cluster & everything else**:
```bash
eksctl delete cluster --name observability
```
